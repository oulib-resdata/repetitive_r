---
title: Control Flow
teaching: 45
exercises: 20
questions:
- "How can I make data-dependent choices in R?"
- "How can I repeat operations in R?"
objectives:
- "Write conditional statements with `if()` and `else()`."
- "Write and understand `for()` loops."
keypoints:
- "Use `if` and `else` to make choices."
- "Use `for` to repeat operations."
source: Rmd
---

```{r, include=FALSE}
source("../bin/chunk-options.R")
knitr_fig_path("07-")
# Silently load in the data so the rest of the lesson works
gapminder <- read.csv("data/gapminder_data.csv", header=TRUE)
# Silently set seed for random number generation, so we don't have to explain it
set.seed(10)
```

## Repeating operations

If you want to iterate over
a set of values, when the order of iteration is important, and perform the
same operation on each, a `for()` loop will do the job.
We saw `for()` loops in the shell lessons earlier. This is the most
flexible of looping operations, but therefore also the hardest to use
correctly. Avoid using `for()` loops unless the order of iteration is important:
i.e. the calculation at each iteration depends on the results of previous iterations.

The basic structure of a `for()` loop is:

```{r, eval=FALSE}
for(iterator in set of values){
  do a thing
}
```

For example:

```{r}
for(i in 1:10){
  print(i)
}
```

The `1:10` bit creates a vector on the fly; you can iterate
over any other vector as well.

We can use a `for()` loop nested within another `for()` loop to iterate over two things at
once.

```{r}
for(i in 1:5){
  for(j in c('a', 'b', 'c', 'd', 'e')){
    print(paste(i,j))
  }
}
```

Rather than printing the results, we could write the loop output to a new object.

```{r}
output_vector <- c()
for(i in 1:5){
  for(j in c('a', 'b', 'c', 'd', 'e')){
    temp_output <- paste(i, j)
    output_vector <- c(output_vector, temp_output)
  }
}
output_vector
```

This approach can be useful, but 'growing your results' (building
the result object incrementally) is computationally inefficient, so avoid
it when you are iterating through a lot of values.

> ## Tip: don't grow your results
>
> One of the biggest things that trips up novices and
> experienced R users alike, is building a results object
> (vector, list, matrix, data frame) as your for loop progresses.
> Computers are very bad at handling this, so your calculations
> can very quickly slow to a crawl. It's much better to define
> an empty results object before hand of the appropriate dimensions.
> So if you know the end result will be stored in a matrix like above,
> create an empty matrix with 5 row and 5 columns, then at each iteration
> store the results in the appropriate location.
{: .callout}

A better way is to define your (empty) output object before filling in the values.
For this example, it looks more involved, but is still more efficient.

```{r}
output_matrix <- matrix(nrow=5, ncol=5)
j_vector <- c('a', 'b', 'c', 'd', 'e')
for(i in 1:5){
  for(j in 1:5){
    temp_j_value <- j_vector[j]
    temp_output <- paste(i, temp_j_value)
    output_matrix[i, j] <- temp_output
  }
}
output_vector2 <- as.vector(output_matrix)
output_vector2
```

> ## Tip: While loops
>
>
> Sometimes you will find yourself needing to repeat an operation as long as a certain
> condition is met. You can do this with a `while()` loop.
>
> ```{r, eval=FALSE}
> while(this condition is true){
>   do a thing
> }
> ```
> R will interpret a condition being met as "TRUE".
>
> As an example, here's a while loop
> that generates random numbers from a uniform distribution (the `runif()` function)
> between 0 and 1 until it gets one that's less than 0.1.
>
> ~~~
> z <- 1
> while(z > 0.1){
>   z <- runif(1)
>   cat(z, "\n")
> }
> ~~~
> {: .r}
>
>`while()` loops will not always be appropriate. You have to be particularly careful
> that you don't end up stuck in an infinite loop because your condition is always met and hence the while statement never terminates.
{: .callout}


> ## Challenge 2
>
> Compare the objects output_vector and
> output_vector2. Are they the same? If not, why not?
> How would you change the last block of code to make output_vector2
> the same as output_vector?
>
> > ## Solution to Challenge 2
> > We can check whether the two vectors are identical using the `all()` function:
> > ```{r ch10pt6-sol, eval=FALSE}
> > all(output_vector == output_vector2)
> > ```
> > However, all the elements of `output_vector` can be found in `output_vector2`:
> > ```{r ch10pt7-sol, eval=FALSE}
> > all(output_vector %in% output_vector2)
> > ```
> > and vice versa:
> > ```{r ch10pt8-sol, eval=FALSE}
> > all(output_vector2 %in% output_vector)
> > ```
> > therefore, the element in `output_vector` and `output_vector2` are just sorted in a different order.
> > This is because `as.vector()` outputs the elements of an input matrix going over its column.
> > Taking a look at `output_matrix`, we can notice that we want its elements by rows.
> > The solution is to transpose the `output_matrix`. We can do it either by calling the transpose function
> > `t()` or by inputing the elements in the right order.
> > The first solution requires to change the original
> > ```{r ch10pt9-sol, eval=FALSE}
> > output_vector2 <- as.vector(output_matrix)
> > ```
> > into
> > ```{r ch10pt10-sol, eval=FALSE}
> > output_vector2 <- as.vector(t(output_matrix))
> > ```
> > The second solution requires to change
> > ```{r ch10pt11-sol, eval=FALSE}
> > output_matrix[i, j] <- temp_output
> > ```
> > into
> > ```{r ch10pt12-sol, eval=FALSE}
> > output_matrix[j, i] <- temp_output
> > ```
> {: .solution}
{: .challenge}

> ## Challenge 3
>
> Write a script that loops through the `gapminder` data by continent and prints out
> whether the mean life expectancy is smaller or larger than 50
> years.
>
> > ## Solution to Challenge 3
> >
> > **Step 1**:  We want to make sure we can extract all the unique values of the continent vector
> > ```{r 07-chall-03-sol-a, eval=FALSE}
> > gapminder <- read.csv("data/gapminder_data.csv")
> > unique(gapminder$continent)
> > ```
> >
> > **Step 2**: We also need to loop over each of these continents and calculate the average life expectancy for each `subset` of data.
> > We can do that as follows:
> >
> > 1. Loop over each of the unique values of 'continent'
> > 2. For each value of continent, create a temporary variable storing that subset
> > 3. Return the calculated life expectancy to the user by printing the output:
> >
> > ```{r 07-chall-03-sol-b, eval=FALSE}
> > for( iContinent in unique(gapminder$continent) ){
> >   tmp <- gapminder[gapminder$continent == iContinent, ]   
> >   cat(iContinent, mean(tmp$lifeExp, na.rm = TRUE), "\n")  
> >   rm(tmp)
}
> > ```
> >
> > **Step 3**: The exercise only wants the output printed if the average life expectancy is less than 50 or greater than 50. So we need to add an `if()` condition before printing.
> > So we need to add an `if()` condition before printing, which evaluates whether the calculated average life expectancy is above or below a threshold, and print an output conditional on the result.
> > We need to amend (3) from above:
> >
> > 3a. If the calculated life expectancy is less than some threshold (50 years), return the continent and a statement that life expectancy is less than threshold, otherwise return the continent and   a statement that life expectancy is greater than threshold,:
> >
> > ```{r 07-chall-03-sol-c, eval=FALSE}
> > thresholdValue <- 50
> >
> > for( iContinent in unique(gapminder$continent) ){
> >    tmp <- mean(gapminder[gapminder$continent == iContinent, "lifeExp"])
> >    
> >    if(tmp < thresholdValue){
> >        cat("Average Life Expectancy in", iContinent, "is less than", thresholdValue, "\n")
> >    }
> >    else{
> >        cat("Average Life Expectancy in", iContinent, "is greater than", thresholdValue, "\n")
> >         } # end if else condition
> >    rm(tmp)
> >    } # end for loop
> >
> > ```
> {: .solution}

